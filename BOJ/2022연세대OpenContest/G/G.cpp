#define _CRT_SECURE_NO_WARNINGS 
#include <bits/stdc++.h>
using std::vector;
//최대숫자max이 있다면, 1부터 max까지 모든 자연수가 최소 1개씩은나와야함
//n숫자갯수 m숫자중최댓값
//num 각숫자마다 빈도수 체크
//res 실제로 만들어질 계단수 => 만들다가 실패시 -1출력하면됨
int n, max=0, min=100000, * num; 
vector<int> input;

int main(void) {
	scanf("%d", &n);
	//숫자들을 입력받음
	for (int i = 0, _; i < n; i++) {
		scanf("%d", &_);
		input.push_back(_);
		if (max <= _) max = _; //최댓값 체크
		if (min >= _) min = _; //최솟값 체크
	}

	//최솟값과 최댓값이 동일하면 모두 같은수를 입력받은것이므로 오류
	//동시에 n==1 일때도 오류로 체크됨
	if (min == max) {
		printf("-1");
		return 0;
	}

	//입력받은 숫자들의 빈도수 체크
	num = new int[max + 1]; //1~m 까지 수의 빈도수를 저장할것
	for (int i = 0; i < max + 1; i++) num[i] = 0; //초기화
	for (int i = 0; i < n; i++) num[input[i]]++; //빈도수 세기

	//필요없어진 벡터 정리
	input.clear(); 

	//만약 min + 1 ~ max - 1까지 숫자가 최소 2개는 있어야
	//'  ㅅ  ' 모양의 계단수를 만들수있음.
	//min 과 max 는 각각 최소 1개고, 1개뿐일 수 있으므로 제외
	for (int i = min + 1; i <= max - 1; i++)
		if (num[i] < 2) {
			printf("-1");
			return 0; 
		}

	//일반계단수는 현재레벨의 계단을 두개만남기고
	//모든계단을 2레벨위로 올리면서 최종적으로 ' ㅅ ' 자가 만들어지는 수의 집합.
	//우리가 구할것은 병철계단수고, 병철계단수는 최하레벨 계단수에서 오른쪽(맨뒤)이 하나가 없는상태.
	//따라서 일반계단수로 만들어 계산하기위해 최하레벨계단수를 +1한다.
	//올린계단수 => 현재레벨에서 2개를 빼서 2레벨위로 올릴 계단수.
	//				이미 아래층에서 2레벨위로올렸으니, 현재레벨에서는 다음레벨의 올림수를 의미.
	//				모든요소를 확인뒤, 현재레벨에서 2개를뺀뒤 2레벨위로 올릴 계단수로 저장함
	num[min]++; //일반계단수로 계산하기위해 최하레벨계단수 + 1
	int upper = 0; 
	//min부터 max(최대 높이)이전 까지
	//최소값:현재레벨의계단수 -1
	for (int lv = min; lv < max; lv++) { 
		//다음레벨의 계단수 계산
		int nextLV = num[lv + 1];

		//2. 다음레벨의 계단수가 정상인지 판별
		//정상범위 : 현재레벨의계단수 -1 <= 다음레벨계단수
		//비정상범위 : 다음레벨계단수 < 현재레벨의계단수 -1
		if (nextLV < num[lv] - 1) {
			printf("-1");
			return 0;
		}

		//3. 현재 레벨에 2개만 남기고 나머지는 모두 2레벨 올린다.
		upper = num[lv] - 2; //현재레벨에서 2개만뺌
		if (lv != max - 1) //인덱스초과 방지
			num[lv + 2] += upper; //2레벨위 계단수로 올림
	}

	//max층 이후 높이에선 올려진 upper들로만 모두 올릴수있으므로
	//max층에서 계단수가 만들어질 수 있다면
	//이보다 상위레벨에서 모두 계단수가 만들어질수있음
	//upper : max-1 층에서 올린 계단수 즉 max+1층에 올려진 계단수
	if (num[max] == upper + 1) {  //max층과 바로 위인 max+1계단수만 비교
		printf("1"); 
		return 0;
	}
	else { //비정상이면
		printf("-1");
		return 0;
	}


	return 0;
}